#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ring_path_spectra.py 

Plots binned JFM and JAS spectra for two adjacent patches
in the Agulhas "ring path" region. 
Also plots the ratio of the two with confidence
limits generated by the f-test. Uses output from
jason_patch_spectrum_all.py, for (8 deg)^2 grid
boxes centered at 34S 10E and 38S 10E.


Created on Sun Aug 15 09:24:54 2021

@author: albionlawrence with modifications by joernc
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as mticker
import sys
from scipy.io import loadmat
import matplotlib.cm as cm
from scipy.optimize import least_squares
import netCDF4 as nc
from scipy.stats import chi2, f
import scipy.integrate as sint
from string import ascii_lowercase
#import seaborn as sns
#from scipy.optimize import least_squares

lat1 = -34
lat2 = -38
lon = 10
x_int = int(lon/8)
y_int_1 = int((lat1+60)/8)
y_int_1 = int((lat2+60)/8)
M2 = 2*np.pi/(12.42*3600)
grav = 9.8
f1 = 2*np.pi*np.sin(2*np.pi*lat1/360)/(12*3600)
f2 = 2*np.pi*np.sin(2*np.pi*lat2/360)/(12*3600)
months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec']

spec_1 = loadmat('../submesoscale_seasonality_data/patch_spectra/jason_lat{:n}_lon{:n}_8deg_unfiltered.mat'.format(lat1,lon))
spec_2 = loadmat('../submesoscale_seasonality_data/patch_spectra/jason_lat{:n}_lon{:n}_8deg_unfiltered.mat'.format(lat2,lon))

ps_all_1 = spec_1['ps_all'][:,:,1:]
ps_all_2 = spec_2['ps_all'][:,:,1:]

dx_1 = spec_1['dx'][0][0]
num_segs_1 = spec_1['num_segs']
good_cycles_1 = spec_1['good_cycles']
pass_list_1 = spec_1['pass_list'][0,:]
month_list_1 = spec_1['month_list']
high_cycle_1 = spec_1['high_cycle'][0][0]
low_cycle_1 = spec_1['low_cycle'][0][0]
constant_mode_array_1 = spec_1['constant_mode_array']
fft_len_1 = ps_all_1.shape[2] + 1

dx_2 = spec_2['dx'][0][0]
num_segs_2 = spec_2['num_segs']
good_cycles_2 = spec_2['good_cycles']
pass_list_2 = spec_2['pass_list'][0,:]
month_list_2 = spec_2['month_list']
high_cycle_2 = spec_2['high_cycle'][0][0]
low_cycle_2 = spec_2['low_cycle'][0][0]
constant_mode_array_2 = spec_2['constant_mode_array']
fft_len_2 = ps_all_2.shape[2] + 1

#multiplier for converting SSH power spectra in m^2/cpkm to KE spectrum in m^3
track_length = 160
dk_1 = 1/(track_length*dx_1)
wn_km_1 = np.arange(1,fft_len_1)*dk_1
wn_m_1 = np.arange(1,fft_len_1)*dk_1/1000 #wavenumber in 1/m
awn_m_1= 2*np.pi*wn_m_1 #angular wavenumber
ssh_to_ke_1 = 2*awn_m_1**2*grav**2/f1**2

dk_2 = 1/(track_length*dx_2)
wn_km_2 = np.arange(1,fft_len_2)*dk_2
wn_m_2 = np.arange(1,fft_len_2)*dk_2/1000 #wavenumber in 1/m
awn_m_2 = 2*np.pi*wn_m_2 #angular wavenumber
ssh_to_ke_2 = 2*awn_m_2**2*grav**2/f2**2


#factor of 2 to get u**2 + v**2; factor of 1000 to convert the dx
#used in cmoputing the SSH PSD (which is importd in m^2/(cpkm))

#Data for "good" passes with enough data
good_passes_1 = np.where(np.amin(num_segs_1,axis=0) > 4)[0]
good_passes_1 = np.unique(good_passes_1) 
pass_list_good_1 = pass_list_1[good_passes_1]
month_list_good_1 = month_list_1[good_passes_1,:]
num_good_segs_1 = num_segs_1[:,good_passes_1]
num_segs_patch_1 = np.sum(num_good_segs_1,axis=1)
num_good_passes_1 = len(pass_list_good_1)
good_cycles_good_passes_1 = good_cycles_1[good_passes_1,:]
ps_good_1 = ps_all_1[good_passes_1,:,:]

good_passes_2 = np.where(np.amin(num_segs_1,axis=0) > 4)[0]
good_passes_2 = np.unique(good_passes_1) 
pass_list_good_2 = pass_list_1[good_passes_1]
month_list_good_2 = month_list_1[good_passes_1,:]
num_good_segs_2 = num_segs_1[:,good_passes_1]
num_segs_patch_2 = np.sum(num_good_segs_1,axis=1)
num_good_passes_2 = len(pass_list_good_1)
good_cycles_good_passes_2 = good_cycles_1[good_passes_2,:]
ps_good_2 = ps_all_1[good_passes_2,:,:]


#Now let's generate monthly spectra and binned spectra for patch
#"Unfiltered" because onlike monthly spectra I do not remove passes
#with fewwer than 4 gap-free racks in a calendar month (binning givesmore statistics)
num_unfiltered_jfm_1 = np.sum(num_segs_1[0:3,:])
num_unfiltered_jas_1 = np.sum(num_segs_1[6:9,:])
num_unfiltered_jfm_2 = np.sum(num_segs_2[0:3,:])
num_unfiltered_jas_2 = np.sum(num_segs_2[6:9,:])

monthly_unfiltered_spectrum_1 = np.zeros((12,high_cycle_1 - low_cycle_1 + 1,fft_len_1-1))
monthly_unfiltered_spectrum_2 = np.zeros((12,high_cycle_2 - low_cycle_2 + 1,fft_len_2-1))


for k, p in enumerate(pass_list_1):
    cycle_indx_1 = np.nonzero(good_cycles_1[k,:])[0]
    for n,cycle in enumerate(cycle_indx_1):
        if month_list_1[k,cycle] == np.nan:
            print('hah')
        monthly_unfiltered_spectrum_1[int(month_list_1[k,cycle]),k,:] += ps_all_1[k,cycle,:]
        
for k, p in enumerate(pass_list_2):
    cycle_indx_2 = np.nonzero(good_cycles_2[k,:])[0]
    for n,cycle in enumerate(cycle_indx_2):
        if month_list_2[k,cycle] == np.nan:
            print('hah')
        monthly_unfiltered_spectrum_2[int(month_list_2[k,cycle]),k,:] += ps_all_2[k,cycle,:]
            
unfiltered_ssh_jfm_1 = np.sum(monthly_unfiltered_spectrum_1[0:3,:,:],axis=(0,1))/num_unfiltered_jfm_1
unfiltered_ssh_jas_1 = np.sum(monthly_unfiltered_spectrum_1[5:8,:,:],axis=(0,1))/num_unfiltered_jas_1

unfiltered_ssh_jfm_2 = np.sum(monthly_unfiltered_spectrum_2[0:3,:,:],axis=(0,1))/num_unfiltered_jfm_2
unfiltered_ssh_jas_2 = np.sum(monthly_unfiltered_spectrum_2[5:8,:,:],axis=(0,1))/num_unfiltered_jas_2

#Now lets compute some likelihoods
hiCL_ssh_jfm_1 = (num_unfiltered_jfm_1)*unfiltered_ssh_jfm_1/chi2.interval(.95,num_unfiltered_jfm_1)[0]
loCL_ssh_jfm_1 = (num_unfiltered_jfm_1)*unfiltered_ssh_jfm_1/chi2.interval(.95,num_unfiltered_jfm_1)[1]
hiCL_ssh_jas_1 = (num_unfiltered_jas_1)*unfiltered_ssh_jas_1/chi2.interval(.95,num_unfiltered_jas_1)[0]
loCL_ssh_jas_1 = (num_unfiltered_jas_1)*unfiltered_ssh_jas_1/chi2.interval(.95,num_unfiltered_jas_1)[1]
hiCL_ssh_jfm_2 = (num_unfiltered_jfm_2)*unfiltered_ssh_jfm_2/chi2.interval(.95,num_unfiltered_jfm_2)[0]
loCL_ssh_jfm_2 = (num_unfiltered_jfm_2)*unfiltered_ssh_jfm_2/chi2.interval(.95,num_unfiltered_jfm_2)[1]
hiCL_ssh_jas_2 = (num_unfiltered_jas_2)*unfiltered_ssh_jas_2/chi2.interval(.95,num_unfiltered_jas_2)[0]
loCL_ssh_jas_2 = (num_unfiltered_jas_2)*unfiltered_ssh_jas_2/chi2.interval(.95,num_unfiltered_jas_2)[1]

#Finally we wish to compute the F statistic for the SSH power interpreted as a variance.
ratio_unfiltered_1 = unfiltered_ssh_jfm_1/unfiltered_ssh_jas_1
F_low_1 = f.interval(.95,num_unfiltered_jas_1,num_unfiltered_jfm_1)[0]
F_hi_1 = f.interval(.95,num_unfiltered_jas_1,num_unfiltered_jfm_1)[1]

ratio_unfiltered_2 = unfiltered_ssh_jfm_2/unfiltered_ssh_jas_2
F_low_2 = f.interval(.95,num_unfiltered_jas_2,num_unfiltered_jfm_2)[0]
F_hi_2 = f.interval(.95,num_unfiltered_jas_2,num_unfiltered_jfm_2)[1]

lat1_s = "{:d}°N".format(lat1) if lat1 > 0 else "{:d}°S".format(-lat1)
lat2_s = "{:d}°N".format(lat2) if lat2 > 0 else "{:d}°S".format(-lat2)
lon_s = "{:d}°E".format(lon) if lon < 180 else "{:d}°W".format(360-lon)

fig, ax = plt.subplots(3, 2, sharex=True, sharey="row", figsize=(8, 10.8))

ax[0,0].loglog(wn_km_1,unfiltered_ssh_jfm_1,label='JFM', color='tab:blue', zorder=1)
ax[0,0].loglog(wn_km_1,unfiltered_ssh_jas_1,label='JAS', color='tab:orange', zorder=2)
ax[0,0].fill_between(wn_km_1,loCL_ssh_jfm_1,hiCL_ssh_jfm_1, color='tab:blue', alpha=0.3, linewidths=0, zorder=1)
ax[0,0].fill_between(wn_km_1,loCL_ssh_jas_1,hiCL_ssh_jas_1, color='tab:orange', alpha=0.3, linewidths=0, zorder=2)
ax[0,0].set_ylabel('SSH power spectral density (m$^2$ cpkm$^{-1}$)')
ax[0,0].legend(frameon=False)
ax[0,0].set_xlim(1e-3, 1e-1)

ax[0,1].loglog(wn_km_2,unfiltered_ssh_jfm_2,label='JFM', color='tab:blue', zorder=1)
ax[0,1].loglog(wn_km_2,unfiltered_ssh_jas_2,label='JAS', color='tab:orange', zorder=2)
ax[0,1].fill_between(wn_km_2,loCL_ssh_jfm_2,hiCL_ssh_jfm_2, color='tab:blue', alpha=0.3, linewidths=0, zorder=1)
ax[0,1].fill_between(wn_km_2,loCL_ssh_jas_2,hiCL_ssh_jas_2, color='tab:orange', alpha=0.3, linewidths=0, zorder=2)
ax[0,1].legend(frameon=False)

ax[1,0].loglog(wn_km_1, ssh_to_ke_1*unfiltered_ssh_jfm_1, label='JFM', color='tab:blue', zorder=1)
ax[1,0].loglog(wn_km_1, ssh_to_ke_1*unfiltered_ssh_jas_1, label='JAS', color='tab:orange', zorder=2)
ax[1,0].fill_between(wn_km_1, ssh_to_ke_1*loCL_ssh_jfm_1, ssh_to_ke_1*hiCL_ssh_jfm_1, color='tab:blue', alpha=0.3, linewidths=0, zorder=1)
ax[1,0].fill_between(wn_km_1, ssh_to_ke_1*loCL_ssh_jas_1, ssh_to_ke_1*hiCL_ssh_jas_1, color='tab:orange', alpha=0.3, linewidths=0, zorder=2)
ax[1,0].set_ylabel('KE spectral density (m$^2$ s$^{-2}$ cpkm$^{-1}$)')
ax[1,0].legend(frameon=False)

ax[1,1].loglog(wn_km_2,ssh_to_ke_2*unfiltered_ssh_jfm_2,label='JFM', color='tab:blue', zorder=1)
ax[1,1].loglog(wn_km_2,ssh_to_ke_2*unfiltered_ssh_jas_2,label='JAS', color='tab:orange', zorder=2)
ax[1,1].fill_between(wn_km_2,ssh_to_ke_2*loCL_ssh_jfm_2,ssh_to_ke_2*hiCL_ssh_jfm_2, color='tab:blue', alpha=0.3, linewidths=0, zorder=1)
ax[1,1].fill_between(wn_km_2,ssh_to_ke_2*loCL_ssh_jas_2,ssh_to_ke_2*hiCL_ssh_jas_2, color='tab:orange', alpha=0.3, linewidths=0, zorder=2)
ax[1,1].legend(frameon=False)

ax[2,0].loglog(wn_km_1,ratio_unfiltered_1)
ax[2,0].fill_between(wn_km_1,F_low_1*ratio_unfiltered_1,F_hi_1*ratio_unfiltered_1, color='tab:blue', alpha=0.3, linewidths=0)
ax[2,0].axhline(1, color='black', linewidth=0.8)
ax[2,0].set_xlabel('wavenumber (cpkm)')
ax[2,0].set_ylabel('ratio of JFM to JAS spectrum')

ax[2,1].loglog(wn_km_2,ratio_unfiltered_2)
ax[2,1].fill_between(wn_km_2,F_low_2*ratio_unfiltered_2,F_hi_2*ratio_unfiltered_2, color='tab:blue', alpha=0.3, linewidths=0)
ax[2,1].axhline(1, color='black', linewidth=0.8)
ax[2,1].set_xlabel('wavenumber (cpkm)')

ax[2,0].set_yticks([1])
ax[2,0].set_yticks([i/10 for i in range(4, 10)] + [2], minor=True)
ax[2,0].set_yticklabels([1.0])
ax[2,0].set_yticklabels([None, 0.5, None, None, None, None, 2.0], minor=True)
ax[2,0].set_ylim(0.4, 2)

for i in range(3):
    ax[i,0].set_title('{:s} {:s}'.format(lat1_s, lon_s))
    ax[i,1].set_title('{:s} {:s}'.format(lat2_s, lon_s))

for i in range(6):
    ax[i//2,i%2].set_title("({:s})".format(ascii_lowercase[i]), loc="left")

fig.align_ylabels()
fig.tight_layout()
fig.savefig("fig/binned_spectra_rp.pdf")

plt.show()
